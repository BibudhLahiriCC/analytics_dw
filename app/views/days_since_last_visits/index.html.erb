<script src="http://mbostock.github.com/d3/d3.js?2.7.1"></script>
<script src="http://mbostock.github.com/d3/d3.layout.js?2.7.1"></script>
<style>

body {
  font: 10px sans-serif;
}

.chart rect {
  fill: steelblue;
  stroke: white;
}

line {
  stroke: black;
  shape-rendering: crispEdges;
}

.box { font: 10px sans-serif; }
.box line, .box rect, .box circle { stroke: #000; stroke-width: 1.5px; fill: #fff; }
.box .center { stroke-dasharray: 3 3; }
.box .outlier { stroke: #ccc; fill: none; }

</style>
<body>
<script>

var data = <%= @days_since_last_visits %>;

//Draw the histogram.
var histogram = d3.layout.histogram()
                (data);
/*The layout object returned by d3.layout.histogram()
  is both an object and a function. Since it is a function,
  it can be invoked with the parameter "data". "histogram" is an
  array with the frequencies of the different buckets.*/

var width = 480,
    height = 250;

//x and y defined below are functions. Used later.
var x = d3.scale.ordinal()
    .domain(histogram.map(function(d) { return d.x; }))
    .rangeRoundBands([0, width]);

var y = d3.scale.linear()
    .domain([0, d3.max(histogram.map(function(d) { return d.y; }))])
    .range([0, height]);

//Create an SVG container here
//var svg
  var chart = d3.select("#histgrm").append("svg")
    .attr("class", "chart")
    .attr("width", width)
    .attr("height", height);

/*The data array "histogram" is being bound/joined to a selection.
  We are using the enter() operator because there are, at this
  point, no nodes in the DOM of type "rect". d.x is lower bound of histogram
  bin. d.y is the frequency.*/

  chart.selectAll("rect")
    .data(histogram)
    .enter().append("rect")
    .attr("width", x.rangeBand())
    .attr("x", function(d) { return x(d.x); })
    .attr("y", function(d) { return height - y(d.y); })
    .attr("height", function(d) { return y(d.y); });

/*Label the histogram bins. The return type is a selection of
  objects of class SVGTextElement. We do not need the index in the
  key function.*/

  var labels =
    chart.selectAll("text")
      .data(histogram)
      //.select(function(d, i) { return i & 1 ? this : null; })
      .enter().append("svg:text")
      .attr("x", function(d) { return x(d.x); })
      .attr("y", height - 20)
      .attr("dx", 4)
      .attr("dy", ".71em")
      .attr("text-anchor", "start")
      .text(function(d) { return x(d.x); })
      .attr("font-family", "sans-serif")
      .attr("font-size", "5 px")
      .attr("fill", "black");

      //Draw a line at the bottom of the histogram
chart.append("line")
    .attr("x1", 0)
    .attr("x2", width)
    .attr("y1", height)
    .attr("y2", height);

//Draw the box plot
var w = 120,
    h = 500,
    m = [10, 50, 20, 50], // top right bottom left
    min = Infinity,
    max = -Infinity;

 var i=0;
 var data_size = data.length;
 for (i = 0; i < data_size; i++)
 {
   if (data[i] > max)
    max = data[i];
   if (data[i] < min)
    min = data[i];
  }

  /*In a box-and-whisker plot, whiskers are drawn at Q3 + 1.5*IQR
    and Q1 - 1.5*IQR. There may be outliers beyond these lines.
    The call to iqr() returns those numbers.
    boxChart() returns a "box" (which is an object as well as a function),
    on which box.whiskers(), box.width and box.height are called in chain.*/

  var boxPlot = boxChart()
    .whiskers(iqr(1.5))
    .width(w - m[1] - m[3])
    .height(h - m[0] - m[2]);

  boxPlot.domain([min, max]);

  /*The ‘svg:g’ element is a container element for
  grouping together related graphics elements. The
  translation shifts the origin of the coordinate axes
  m[3] = 50 units to right and m[0] = 10 units down.*/

  var vis = d3.select("#boxplt").selectAll("svg")
      .data(data)
    .enter().append("svg")
      .attr("class", "box")
      .attr("width", w)
      .attr("height", h)
    .append("g")
      .attr("transform", "translate(" + m[3] + "," + m[0] + ")")
      .call(boxPlot);

  // Returns a function to compute the interquartile range.
  function iqr(k) {
    return function(d, i) {
    //quartiles are functions that come from boxQuartiles,
    //which come from quantiles
    var q1 = d.quartiles[0],
        q3 = d.quartiles[2],
        iqr = (q3 - q1) * k,
        i = -1,
        j = d.length;
    while (d[++i] < q1 - iqr);
    while (d[--j] > q3 + iqr);
    return [i, j];
  };
}

// Inspired by http://informationandvisualization.de/blog/box-plot
function boxChart() {
  var wdth = 1,
      hght = 1,
      duration = 0,
      domain = null,
      value = Number,
      whiskers = boxWhiskers,
      quartiles = boxQuartiles,
      tickFormat = null;

  // For each small multiple…
  function box(g) {
    g.each(function(d, i) {
      d = d.map(value).sort(d3.ascending);
      var g = d3.select(this),
          n = d.length,
          min = d[0],
          max = d[n - 1];

      // Compute quartiles. Must return exactly 3 elements.
      var quartileData = d.quartiles = quartiles(d);

      // Compute whiskers. Must return exactly 2 elements, or null.
      var whiskerIndices = whiskers && whiskers.call(this, d, i),
          whiskerData = whiskerIndices && whiskerIndices.map(function(i) { return d[i]; });

      // Compute outliers. If no whiskers are specified, all data are "outliers".
      // We compute the outliers as indices, so that we can join across transitions!
      var outlierIndices = whiskerIndices
          ? d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n))
          : d3.range(n);

      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain(domain && domain.call(this, d, i) || [min, max])
          .range([hght, 0]);

      // Retrieve the old x-scale, if this is an update.
      var x0 = this.__boxPlot__ || d3.scale.linear()
          .domain([0, Infinity])
          .range(x1.range());

      // Stash the new scale.
      this.__boxPlot__ = x1;

      // Note: the box, median, and box tick elements are fixed in number,
      // so we only have to handle enter and update. In contrast, the outliers
      // and other elements are variable, so we need to exit them! Variable
      // elements also fade in and out.

      // Update center line: the vertical line spanning the whiskers.
      var center = g.selectAll("line.center")
          .data(whiskerData ? [whiskerData] : []);

      center.enter().insert("svg:line", "rect")
          .attr("class", "center")
          .attr("x1", wdth / 2)
          .attr("y1", function(d) { return x0(d[0]); })
          .attr("x2", wdth / 2)
          .attr("y2", function(d) { return x0(d[1]); })
          .style("opacity", 1e-6)
        .transition()
          .duration(duration)
          .style("opacity", 1)
          .attr("y1", function(d) { return x1(d[0]); })
          .attr("y2", function(d) { return x1(d[1]); });

      center.transition()
          .duration(duration)
          .style("opacity", 1)
          .attr("y1", function(d) { return x1(d[0]); })
          .attr("y2", function(d) { return x1(d[1]); });

      center.exit().transition()
          .duration(duration)
          .style("opacity", 1e-6)
          .attr("y1", function(d) { return x1(d[0]); })
          .attr("y2", function(d) { return x1(d[1]); })
          .remove();

      // Update innerquartile box.
      var box = g.selectAll("rect.box")
          .data([quartileData]);

      box.enter().append("svg:rect")
          .attr("class", "box")
          .attr("x", 0)
          .attr("y", function(d) { return x0(d[2]); })
          .attr("width", wdth)
          .attr("height", function(d) { return x0(d[0]) - x0(d[2]); })
        .transition()
          .duration(duration)
          .attr("y", function(d) { return x1(d[2]); })
          .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

      box.transition()
          .duration(duration)
          .attr("y", function(d) { return x1(d[2]); })
          .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

      // Update median line.
      var medianLine = g.selectAll("line.median")
          .data([quartileData[1]]);

      medianLine.enter().append("svg:line")
          .attr("class", "median")
          .attr("x1", 0)
          .attr("y1", x0)
          .attr("x2", wdth)
          .attr("y2", x0)
        .transition()
          .duration(duration)
          .attr("y1", x1)
          .attr("y2", x1);

      medianLine.transition()
          .duration(duration)
          .attr("y1", x1)
          .attr("y2", x1);

      // Update whiskers.
      var whisker = g.selectAll("line.whisker")
          .data(whiskerData || []);

      whisker.enter().insert("svg:line", "circle, text")
          .attr("class", "whisker")
          .attr("x1", 0)
          .attr("y1", x0)
          .attr("x2", wdth)
          .attr("y2", x0)
          .style("opacity", 1e-6)
        .transition()
          .duration(duration)
          .attr("y1", x1)
          .attr("y2", x1)
          .style("opacity", 1);

      whisker.transition()
          .duration(duration)
          .attr("y1", x1)
          .attr("y2", x1)
          .style("opacity", 1);

      whisker.exit().transition()
          .duration(duration)
          .attr("y1", x1)
          .attr("y2", x1)
          .style("opacity", 1e-6)
          .remove();

      // Update outliers.
      var outlier = g.selectAll("circle.outlier")
          .data(outlierIndices, Number);

      outlier.enter().insert("svg:circle", "text")
          .attr("class", "outlier")
          .attr("r", 5)
          .attr("cx", wdth / 2)
          .attr("cy", function(i) { return x0(d[i]); })
          .style("opacity", 1e-6)
        .transition()
          .duration(duration)
          .attr("cy", function(i) { return x1(d[i]); })
          .style("opacity", 1);

      outlier.transition()
          .duration(duration)
          .attr("cy", function(i) { return x1(d[i]); })
          .style("opacity", 1);

      outlier.exit().transition()
          .duration(duration)
          .attr("cy", function(i) { return x1(d[i]); })
          .style("opacity", 1e-6)
          .remove();

      // Compute the tick format.
      var format = tickFormat || x1.tickFormat(8);

      // Update box ticks.
      var boxTick = g.selectAll("text.box")
          .data(quartileData);

      boxTick.enter().append("svg:text")
          .attr("class", "box")
          .attr("dy", ".3em")
          .attr("dx", function(d, i) { return i & 1 ? 6 : -6 })
          .attr("x", function(d, i) { return i & 1 ? wdth : 0 })
          .attr("y", x0)
          .attr("text-anchor", function(d, i) { return i & 1 ? "start" : "end"; })
          .text(format)
        .transition()
          .duration(duration)
          .attr("y", x1);

      boxTick.transition()
          .duration(duration)
          .text(format)
          .attr("y", x1);

      // Update whisker ticks. These are handled separately from the box
      // ticks because they may or may not exist, and we want don't want
      // to join box ticks pre-transition with whisker ticks post-.
      var whiskerTick = g.selectAll("text.whisker")
          .data(whiskerData || []);

      whiskerTick.enter().append("svg:text")
          .attr("class", "whisker")
          .attr("dy", ".3em")
          .attr("dx", 6)
          .attr("x", wdth)
          .attr("y", x0)
          .text(format)
          .style("opacity", 1e-6)
        .transition()
          .duration(duration)
          .attr("y", x1)
          .style("opacity", 1);

      whiskerTick.transition()
          .duration(duration)
          .text(format)
          .attr("y", x1)
          .style("opacity", 1);

      whiskerTick.exit().transition()
          .duration(duration)
          .attr("y", x1)
          .style("opacity", 1e-6)
          .remove();
    });
    d3.timer.flush();
  }

  /*The following methods all return "box"
    so that method chaining works.*/

  box.width = function(x) {
    if (!arguments.length) return wdth;
    wdth = x;
    return box;
  };

  box.height = function(x) {
    if (!arguments.length) return hght;
    hght = x;
    return box;
  };

  box.tickFormat = function(x) {
    if (!arguments.length) return tickFormat;
    tickFormat = x;
    return box;
  };

  box.duration = function(x) {
    if (!arguments.length) return duration;
    duration = x;
    return box;
  };

  box.domain = function(x) {
    if (!arguments.length) return domain;
    domain = x == null ? x : d3.functor(x);
    return box;
  };

  box.value = function(x) {
    if (!arguments.length) return value;
    value = x;
    return box;
  };

  box.whiskers = function(x) {
    if (!arguments.length) return whiskers;
    whiskers = x;
    return box;
  };

  box.quartiles = function(x) {
    if (!arguments.length) return quartiles;
    quartiles = x;
    return box;
  };

  return box;
};

function boxWhiskers(d) {
  return [0, d.length - 1];
}

function boxQuartiles(d) {
  return [
    d3.quantile(d, .25),
    d3.quantile(d, .5),
    d3.quantile(d, .75)
  ];
}


</script>

